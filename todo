# fixes
# for 4,4 vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
1. fix -u flag not working (done)

3. fix compiler not overwriting previous source and excecutable when updating (done)
4. add caching system (done)
5. add preprocessor INCLUDE feature

# for 4.5 vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv

1. add modular imports from any text file source e.g
	IMPORT: "header.acn"
	IMPORT: "mylib.txt"
	IMPORT: "mylib2.py"
	IMPORT: "raylib.h"
	IMPORT: "mydir/mylib3.cpp"
	etc.
The preprocessor looks for those files and pastes them in the file calling those libraries
	
2. add multiple file compilation and linkinng e.g

	>yori source1.txt source2.yori source3.acn -o output.exe -cpp -cloud
		
-change query prompt from "expert c++ engineer" to "expert programmer"

# for 5.x vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv

1. yori recognizes when user wants to use it for transpilation,
>yori mysource.x -o mytarget.y -local -y  (currently this makes a binary file with extension .y, we want it to be a text file)
	>add a -t flag for transpilation


1.5 tree shaking

2.Si falla provider primario → intenta secundario automáticamente
Load balancing entre múltiples API keys
Cost optimization (usa modelo más barato para tareas simples)

3. Build Profiles
yori build --profile production  # optimizado, sin debug
yori build --profile debug       # símbolos, validaciones extra
yori build --profile quick       # compilación rápida, menos checks
 
 Developer Experience
4. Interactive Repair Mode
yori fix main.cpp --interactive
AI sugiere 3 opciones de fix, usuario elige

5. Dependency Resolver Mejorado

Auto-download de headers comunes (via vcpkg/conan integration)
Sugerencias: "¿Instalar nlohmann/json automáticamente?"
Detección de versiones incompatibles

6. Project Templates Expandidos
bashyori init --template web-server-cpp
yori init --template cli-tool-rust
yori init --template data-pipeline-python

7. Explain Mode
yori explain output.cpp
 AI documenta cada función/clase generada, genera un el mismo archivo pero con comentarios

8. Diff semantic
yori diff <fileA.ext> <fileB.ext>
	AI hace un archivo .md donde explica los cambios entre ambas versiones (que cambió, dónde), con un resumen al comienzo de la esencia del cambio

9. yori config max-tries <number> 
^^ configura cuantas retries maximo acepta el sistema

10. yori sos [language] [-local | -cloud] "error or problem description"

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

For 5.7

1. If yori finds that the input source code files are 
	1) compiled language
	2) the same language
	
	like this->
`
>yori file.cpp fileb.cpp -o app.exe -cloud 
>yori fileA.rs fileb.rs filec.rs -o app.exe -local
`

Instead of sending the source code to the AI to be transpiled again into c++ (or c or rust or go)(which is redundant), 
yori directly summons the language compiler, only if error appears will the code be fed into a LLM to fix it. 

2. Semantic Tree Shaking (Optimización de Código Muerto)

Contexto: El usuario define interfaces en archivos importados (ej. stdacorn.acn) o importa lógica compleja, pero el programa final solo utiliza una pequeña fracción de las funciones disponibles.
Problema: El LLM tiende a ser "excesivamente servicial" e implementa todas las interfaces/funciones definidas, inflando el código final innecesariamente (ej. de 100 a 2000 líneas).
Objetivo: Implementar un sistema de análisis estático previo a la generación (o posterior a ella) para eliminar funciones, structs y variables que no son referenciadas en el flujo principal del programa.
Implementación requerida:

Análisis de Referencias (Static Analysis):
Antes de enviar el prompt al LLM (o después de recibir el código), Yori debe escanear el código principal (main o INTENT principal) para crear una lista blanca de funciones/métodos que son realmente invocados.
Ejemplo: Si main llama a calculateTax() pero no a calculatePi(), marcar calculatePi como candidato para eliminación.
Filtrado de Contratos (Pre-Prompting):

Si se detecta un archivo importado (como stdacorn) con muchas interfaces, Yori no debe enviar el archivo completo al LLM.
En su lugar, debe generar un archivo temporal o un prompt filtrado que contenga solo las definiciones de las funciones utilizadas.
Instrucción al LLM: "Implementar SOLO las siguientes funciones del contrato: [lista blanca]. Ignorar el resto."
Limpieza Post-Generación (Safety Net):

Una vez el LLM devuelve el código (C++/Rust), Yori ejecuta un segundo pase.

Busca definiciones de funciones que no tengan ninguna llamada en el resto del archivo y las elimina del código fuente final antes de la compilación.
Excepción: Mantener funciones que pertenezcan a interfaces públicas (EXPORT) o que sean virtual/override en lenguajes OOP, a menos que se esté en modo "Single Binary".

3. 3. Smart Iterative Mode (Delta Patching / Non-Destructive Updates)

Contexto: Los proyectos evolucionan. El usuario hace un cambio pequeño en un archivo .acn (ej. añade una función o corrige un INTENT).
Problema: Actualmente, Yori probablemente regenera todo el código fuente desde cero (Full Regeneration) al detectar cambios. Esto es ineficiente, sobrescribe cambios manuales que el usuario pudo haber hecho en el código generado y rompe el flujo de trabajo mental (el "context switch" es alto).
Objetivo: Permitir actualizaciones incrementales. Yori debe ser capaz de detectar qué cambió y aplicar solo ese cambio ("Patch") sobre los archivos existentes, preservando el resto del código.
Implementación requerida:

Detección de Diffs (Semantic Diff):
Comparar el nuevo .acn con la versión anterior (usando el caché de hash o guardando el estado anterior).
Identificar específicamente qué bloque INTENT, INTERFACE o EXPORT fue modificado, añadido o eliminado.

Solicitud de Parche (Targeted Prompting):
En lugar de enviar todo el contexto al LLM, enviar solo:
El bloque de código actual (el archivo C++/Rust existente).

La instrucción específica: "Modifica este archivo para agregar esta nueva función: [descripción]. NO toques el resto del código."
Esto reduce el costo de tokens drásticamente para cambios pequeños.
Modo Preservativo (Safe Merge):

Si el usuario ha editado manualmente el archivo generado (ej. añadió un comentario personal o ajustó un magic number), Yori debe intentar conservar esos cambios.
Utilizar git diff o un algoritmo de merge similar para aplicar el parche de la IA sobre el archivo actual sin borrar las modificaciones manuales, a menos que haya un conflicto directo.
Beneficio esperado:

Convierte a Yori de una herramienta de "Generar y Tirar" a una herramienta de "Desarrollo y Mantenimiento". Permite ciclos de retroalimentación rápidos (seconds en lugar de minutes) y fomenta que el usuario confíe en editar el resultado generado sabiendo que no lo perderá en la próxima compilación.